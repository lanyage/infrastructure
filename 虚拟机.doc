1.Java的内存也就是虚拟管理的内存。
主要分为 java堆，虚拟机栈，本地方法栈，程序计数器，方法区
java堆主要用来为对象分配内存空间，分配内存空间的方式有指针碰撞和空闲列表等技术，具体技术依赖于垃圾回收程序的回收算法策略。
虚拟机栈：用于存放方法的局部变量表，操作数栈，方法出口等信息，局部变量表是在程序编译期间就加载如局部变量表的，所以当方法执行的时候
        局部变量表的大小就已经确定了，正常情况下，栈桢的深度可以非常轻松的达到1000-2000，方法的执行就对应这虚拟机站中栈桢的入栈和出栈。
程序计数器：这个内存是线程私有的，用来记录当前线程执行的字节码指令的地址，分支、循环、跳转和程序的恢复都基于此。
方法区：用来存储类名、类访问权限信息、域和方法的访问信息和常量池
本地方法栈和虚拟机栈类似。
还有一个直接内存,不收到堆内存的影响,一般用于大文件的映射,这样就可以省去频繁的JAVA堆和本地堆内的内存复制,被广泛的用于NIO这类技术上。
涉及的虚拟机参数有 -Xmx -Xms -Xss -XX:PermSize -XX:MaxPermSize -XX:MaxDirectMemorySize
2.java的垃圾收集器与内存分配策略
java内存回收是靠虚拟机底层的低优先级的垃圾回收线程来完成的，而且垃圾收集的策略也是分代执行，因为栈中的内存在程序编译期已经确认了，所以垃圾回收策略在
这块内存不做过多的讨论。
我们所说的垃圾回收主要是回收堆内存和方法区的内存，回收的策略主要分为，停止复制，标记清理和标记整理。对于朝生暮死的短命对象，会使用停止复制策略，对于方法
区中的生命周期比较长的内存则采用标记清理和标记整理的策略。
垃圾回收器按照分代来分主要分为两类，新生代：Serial,Parallel Scavenge,Parnew,其中serial是单线程执行的，因此在单核状态下会效率相对多线程的更加有效，
因为没有了额外的线程上下文之间的开销，也是HotSpot虚拟机的默认新生代的垃圾回收器，parnew则是serial的并行实现，Paralle scavenge是并行的收集，其中只
有parnew和serial能和cms好好配合工作。老年代：serial old,parallel old,cms,其中cms比较特殊，其垃圾回收的策略大致分为初步标记，初步标记就是GCroot
节点能够直接到达的节点，这个阶段需要stopTheWorld,但是时间很短，然后就是并行标记，这个阶段是可以和用户线程共同工作的，只不过可能在刚刚标记完的垃圾可能
又有了其他的引用，因此后面需要重新标记，这部分也需要stopTheWord,By the way,GCroot在jvm中都是通过Oopmap来维护的，因此枚举GCroot并不是枚举所有的
节点，而是Oopmap来维护的节点，重新标记技术之后，会进行一次并行的清理。

对象的内存分配大致是,显示看EDEN有没有足够的空间分配，如果没有则进行一次Minor gc,将对象复制到Survivor中去,Eden和Survivor比例默认是8:1,如果
survivor也没有足够的空间来分配，这时候就需要空间分配担保，使对象进入老年代。对于大对象，可以设置阈值使超过一定大小的对象直接进入老年代，或者设置代数
阈值，使经过n次没有被回收的对象进入老年代。
