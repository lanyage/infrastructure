堆 栈 哈希表 内存泄漏
1.java中的垃圾收集器的优势是什么？
过去的c语言要求程序员显示的分配内存和释放内存，这样一不小心就会引起内存泄漏，程序最终会耗尽内存异常终止，至少无法继续进行。
java不需要程序原先是的分配内存和释放内存，避免了很多潜在的问题。java在创建对象的时候会分配内存，当引用不存在时释放内存。
java使用一系列的软指针来跟踪对象的引用，这些软指针指向的是对象的引用。java垃圾回收器能够作为一种低优先级的线程在后台运行，
并且依次检查每个对象，垃圾回收器可以标记对象、移除对象、移动对象或者检查对象。
垃圾回收器是自动运行的，一般情况下无需显示的请求垃圾收集器。垃圾收集器会不时检查对象的各个引用，并且回收无引用对象所占用的
内存，gc可以提醒垃圾回收器进行垃圾回收，但是不能保证立即会执行。

2.当程序的实时性比较高可以考虑采用增量式内存垃圾回收器，如果系统空闲资源比较多，可以采用并行标记清理
3.当GC操作会影响网络游戏的中断或者web的实时系统的时候，我们可以设置gc参数，让gc能够通过平缓的方式释放内存。hotspot jvm
就支持这一特性。
4.内存泄漏的原因？
全局集合，缓存，ClassLoader
ClassLoader设计元对象的引用，比如字段、方法和类。这意味着只要有对字段、方法、类或者ClassLoader的引用，ClassLoader就
会驻留在JVM中，因为ClassLoader本身可以关联许多类以及静态字段，所有就有许多内存被泄漏。

5.如何定位漏洞的位置？
发生内存泄漏的第一个迹象通常是:在应用程序中出现了OutOfMemoryError,这通常发生在你最不愿意发生的生产环境中，此时基本上不能
进行调试。在这种情况下需要一些开销较低的工具来监控和查找内存泄漏，还需要能够无需重启系统或修改代码就可以将这些工具连接到正在
运行的系统上。可能最重要的是，当进行分析时，需要能够断开工具而保持系统不受干扰。虽然OutOfMemoryError通常都是内存泄漏的信号，
但是也有可能因为程序确实正在使用这么多的内存。对于后者必须增加JVM可用堆的数量。或者对应用程序进行某种修改，使它使用较少的内存。
但是许多情况下OutOfMemoryError都是内存泄漏的信号。一种查明方法是不间断地监控GC的活动，确定内存使用量是否随着时间增加，如果
确定如此，就可能发生了内存泄漏。
