1.I/O是单个字节的移动，一次一个。
2.NIO则是将I/O提升到了块的水平，原始I/O和NIO的最大区块是在于数据如何打包和传输。原始IO处理数据流，而NIO则处理数据块。
3.NIO将最耗时的IO操作移回到了操作系统中，从而可以大大的提升速度。但是NIO的操作块没有操作流来的优雅和简洁。
4.Channels和缓冲区是NIO的中心对象。通道类则类似于流，数据去任何地方都要经过一个Channel对象。
5.Buffer本质上是一个容器对象-数组，发送到频道的所有数据都必须首先放入缓冲区。从Channel读取的任何数据也都要经过缓冲区。
6.缓冲区提供对数据的结构化访问，并且还跟踪系统的读写功能。
7.常用的缓冲区有ByteBuffer,允许在底层数组上进行get和set操作。
  还有ByteBuffer,CharBuffer,ShortBuffer,IntBuffer,LongBuffer,FloatBuffer,DoubleBuffer
  但是ByteBuffer是最独特的。ChunkIn and ChunkOut是NIO的核心。
8.Channel是双向的，而流是单向的。

9.实战：
  从文件中读取。
  1.创建FileInputStream fis = new FileInputStream("file.txt");
  2.FileChannel fc = fis.getChannel();
  3.创建缓冲区:ByteBuffer buffer = ByteBuffer.allocate(1024);
  4.fc.read(buffer);
  写入文件。
  1.FileChannel channel = fileOutputStream.getChannel();
  2.ByteBuffer buffer = ByteBuffer.allocate(1024);
  3.byte[] message = "THIS IS A NEW LINE!".getBytes();
  4.for (int i = 0; i < message.length; i++) {
       buffer.put(message[i]);
    }
  5.buffer.flip();//准备缓冲区以将新都区的数据写入另一个Channel
  6.channel.write(buffer);
10.状态变量
  postion limit capacity
  position表示游标，如果你已经读了3个字节,那么position将指向第4个字节。
  limit表示剩余的数据量。
  capacity表示可以存储在其中的数据的最大量。
  
11.NIO高级部分
  将数组包装成为缓冲区,不过要特别小心
  byte[] array = new byte[1024];
  ByteBuffer.wrap(array);
  
  缓冲区切片
  buffer.position(3)
  buffer.limit(7)
  ByteBuffer slice = buffer.slice();
  
  只读缓冲区
  asReadOnlyBuffer()返回新缓冲区，但是是只读的,并且不能将只读缓冲区转换为可写缓冲区
  
  直接缓冲区
  使用内存映射文件创建直接缓冲区，这种方法比普通的基于流或Channel的IO速度快得多
  这种技术并不是将整个文件读入内存，只有实际读取或写入的文件部分被映射到内存。
  尽管创建起来相当简单，但是写入内存映射文件可能会很危险。通过修改数组中单个元素的简单操作，您可以
  直接修改磁盘上的文件，修改数据并将其保存到磁盘之间没有间隙。
  MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE,0,1024);
  map()方法返回一个MappedByteBuffer,它是ByteBuffer的一个子类。
  
  散射/聚集/IO
  通过可以选择实现两个新的接口：ScatteringByteChannel和GatheringByteChannel.
  这些long read方法与标准的read方法非常相似，不同的是他们不实用单独的缓冲区而是缓冲区数组
  在散射读取中，Channel一次填充每个缓冲区，当它填满一个缓冲区时，它开始填充下一个缓冲区。从某种意义上说。
  缓冲区数组被视为一个大缓冲区。
  散射和聚集将一段数据分成多个部分很有用。例如，您可能正在编写一个使用消息对象的网络应用程序，并且每个消息
  都被分为固定长度标题和固定长度正文。您创建了一个足够大的缓冲区，以及另一个足够大的缓冲区。当你将这两个数组
  放在一个数组中并使用散射读取来读取它们时，标题和正文将在两个缓冲区之间整齐划分。
  
  文件锁定
 
  
  
  
  
